const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const morgan = require('morgan');
const multer = require('multer');
const path = require('path');
require('dotenv').config();

const web3Manager = require('./web3');
      tags: typeof tags === 'string' ? JSON.parse(tags) : tags,
      seller,
      imageUrl: imageFile ? `/uploads/${imageFile.filename}` : null,
      modelUrl: modelFile ? `/uploads/${modelFile.filename}` : null
    }, process.env.PRIVATE_KEY); // Pass the private key from env
    
    res.json({ success: true, ...result });');
const morgan = require('morgan');
const multer = require('multer');
const path = require('path');
require('dotenv').config();

const web3Manager = require('./web3');

const app = express();
const PORT = process.env.PORT || 5000;

// Initialize Web3 or Mock
let web3Instance;

// Security middleware
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: false, // Disable for development
  crossOriginResourcePolicy: { policy: "cross-origin" }
}));

// CORS - allow frontend connections
app.use(cors({
  origin: ['http://localhost:3000', 'http://localhost:8080', 'http://localhost:8081', 'http://localhost:8082'],
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cache-Control', 'Pragma', 'Expires', 'Origin', 'X-Requested-With'],
  exposedHeaders: ['Content-Length', 'Content-Type', 'Access-Control-Allow-Origin']
}));

// Rate limiting - relaxed for development
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000 // Increased from 100 to 1000 for development
});
app.use('/api', limiter);

// Body parsing
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Logging
app.use(morgan('dev'));

// Debug middleware - log ALL incoming requests
app.use((req, res, next) => {
  console.log(`ğŸ” [${new Date().toISOString()}] ${req.method} ${req.originalUrl}`);
  console.log('ğŸ” Headers:', JSON.stringify(req.headers, null, 2));
  if (req.body && Object.keys(req.body).length > 0) {
    console.log('ğŸ” Body:', JSON.stringify(req.body, null, 2));
  }
  next();
});

// Static files - serve uploads and root static files with CORS headers
app.use('/uploads', (req, res, next) => {
  // Add CORS headers for uploaded files
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET, OPTIONS');
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept');
  res.header('Cross-Origin-Resource-Policy', 'cross-origin');
  next();
}, express.static(path.join(__dirname, 'uploads')));

app.use(express.static(path.join(__dirname, '.')));

// Health check
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    web3Connected: web3Manager.connected
  });
});

// Marketplace API endpoints
app.get('/api/marketplace/items', async (req, res) => {
  try {
    const items = await web3Instance.getMarketplaceItems();
    res.json({ success: true, items });
  } catch (error) {
    console.error('âŒ Error fetching marketplace items:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Frontend expects this route for marketplace items
app.get('/api/marketplace', async (req, res) => {
  try {
    const items = await web3Instance.getMarketplaceItems();
    res.json({ success: true, items });
  } catch (error) {
    console.error('âŒ Error fetching marketplace items:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Marketplace stats endpoint
app.get('/api/marketplace/stats', async (req, res) => {
  try {
    const result = await web3Instance.getMarketplaceItems();
    console.log('ğŸ“Š Raw marketplace result:', JSON.stringify(result, null, 2));
    
    // Handle different response structures
    const items = result.items || result || [];
    console.log('ğŸ“Š Items array:', Array.isArray(items), items.length);
    
    if (!Array.isArray(items)) {
      console.log('âš ï¸ Items is not an array:', typeof items, items);
      return res.json({ 
        success: true, 
        stats: {
          totalItems: 0,
          activeItems: 0,
          soldItems: 0,
          totalVolume: 0
        }
      });
    }
    
    const stats = {
      totalItems: items.length,
      activeItems: items.filter(item => !item.sold).length,
      soldItems: items.filter(item => item.sold).length,
      totalVolume: items.reduce((sum, item) => sum + parseFloat(item.price || 0), 0)
    };
    res.json({ success: true, stats });
  } catch (error) {
    console.error('âŒ Error fetching marketplace stats:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Web3 status endpoint
app.get('/api/web3/status', async (req, res) => {
  try {
    const blockNumber = await web3Instance.getBlockNumber();
    const status = {
      connected: web3Instance.connected,
      name: 'localhost',
      chainId: 31337, // Hardhat default chain ID
      contractAddress: web3Instance.contractAddress,
      contractDeployed: web3Instance.isContractDeployed(),
      blockNumber: blockNumber
    };
    console.log('ğŸ“¡ Web3 Status Response:', status);
    res.json({ success: true, data: status }); // Send as 'data' not 'status'
  } catch (error) {
    console.error('âŒ Error fetching Web3 status:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Multer setup for file uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/')
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9)
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname))
  }
});
const upload = multer({ storage: storage });

app.post('/api/marketplace/create', upload.fields([
  { name: 'image', maxCount: 1 },
  { name: 'model', maxCount: 1 }
]), async (req, res) => {
  try {
    const { title, description, price, category, tags, seller } = req.body;
    const imageFile = req.files['image'] ? req.files['image'][0] : null;
    const modelFile = req.files['model'] ? req.files['model'][0] : null;
    
    console.log('ğŸ“¤ Creating marketplace item:', { title, price, seller });
    
    const result = await web3Instance.createMarketItem({
      title,
      description, 
      price,
      category,
      tags: typeof tags === 'string' ? JSON.parse(tags) : tags,
      seller,
      imageUrl: imageFile ? `/uploads/${imageFile.filename}` : null,
      modelUrl: modelFile ? `/uploads/${modelFile.filename}` : null
    });
    
    res.json({ success: true, ...result });
  } catch (error) {
    console.error('âŒ Error creating marketplace item:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Route not found' });
});

// Error handler
app.use((error, req, res, next) => {
  console.error('âŒ Error:', error);
  
  if (error.code === 'LIMIT_FILE_SIZE') {
    return res.status(413).json({ error: 'File too large' });
  }
  
  res.status(500).json({ 
    error: 'Server error',
    details: process.env.NODE_ENV === 'development' ? error.message : undefined
  });
});

// Start server
async function startServer() {
  try {
    console.log('ğŸš€ Starting ChainTorque Web3 Marketplace Backend...');
    
    // Try to initialize real Web3 first
    const web3Connected = await web3Manager.initialize();
    
    if (web3Connected) {
      web3Instance = web3Manager;
      console.log('âœ… Using real Web3 connection');
    } else {
      console.log('âš ï¸  Web3 connection failed, switching to Mock Mode...');
      web3Instance = new MockWeb3Manager();
      await web3Instance.initialize();
      console.log('ğŸ­ Using Mock Web3 for testing');
    }
    
    // Make web3Instance available to routes
    app.locals.web3 = web3Instance;
    
    app.listen(PORT, () => {
      console.log(`\nâœ… Server running on http://localhost:${PORT}`);
      console.log(`ğŸŒ Web3 Status: ${web3Connected ? 'Connected' : 'Mock Mode'}`);
      console.log(`\nğŸ“‹ Available endpoints:`);
      console.log(`   GET  /health - Health check`);
      console.log(`   GET  /api/web3/status - Web3 status`);
      console.log(`   GET  /api/marketplace - Get all items`);
      console.log(`   POST /api/marketplace/create - Create new item`);
      console.log(`   POST /api/upload - Upload file`);
      console.log(`   GET  /api/web3/balance/:address - Get wallet balance`);
    });
    
  } catch (error) {
    console.error('âŒ Failed to start server:', error);
    process.exit(1);
  }
}

startServer();
